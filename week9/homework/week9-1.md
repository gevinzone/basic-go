# 思路

由于目标是“考虑节点负载情况，在选择节点来计算热榜的时候，总是能够选中负载比较低的节点”，所以：
1. 首先要做的事情，还是要抢到分布式锁
2. 然后抢到锁的机器，要做的事为：
   1. 要去查询自己的负载，如果低于阈值，则继续持有锁，并进行热榜计算；
   2. 否则释放锁，让大家重新抢锁，抢到锁的机器依然按这个业务逻辑执行

原因：

一般来说，负载比较高的机器，抢到锁的概率比较低，所以大多数情况下，都是负载较低的机器抢到锁，并计算热榜，符合预期。
如果发生小概率事件，让负责较高的机器抢到锁了，可以让这个机器把锁释放掉，让大家重新抢锁，这样下一轮又是大概率让负载低的机器抢到锁。

方案优化点：

如果对负载要求比较苛刻，阈值设的比较小，那这个方案确实存在多轮抢锁也找不到合适机器的情况，这个方案就不那么合适了。
如果是这种要求，方案可以优化为，每个机器先查询自己的负载，如果低于阈值，再去抢锁，否则不参与本轮抢锁。
如果所有机器的负载都高于阈值，热榜就不再计算了。如果对此不接受，那要考虑“另一种优化方案”。


另一种优化方案是，不需要抢锁，直接让负载最低的机器计算热榜，也可以配个阈值，如果负载最低的机器，负责依然超过阈值，那就延缓计算。
延缓计算的优化点，也可以用类似“重试次数”的方式进行控制，这里不在展开。


# 作业

作业中，直接用没优化的方案实现。
改动文件：
1. 新增 webook/internal/job/load_mock.go 文件
2. 新增 webook/internal/job/ranking_job.go 57-64 行